# Установка и запуск
```sh
bundle install
rake db:setup
rails s
```

# Документация API
## Создание сообщения
### Запрос
```json
POST /messages

{
  "messages": [
    {
      "type": "whatsapp",
      "target": "3948758943",
      "body": "message",
      "deliver_at": "2019-02-25T17:58:07"
    },
    {
      "type": "telegram",
      "target": "3948758943",
      "body": "message"
    }
  ]
}
```
| Поле       | Обязательноe | Описание |
| ---------- |:------------:|:------------:|
| `type`       | Да           | Мессенджер, в который следует отправить сообщение. Возможные значения: `viber`, `telegram`, `whatsapp`|
| `target`     | Да           |Идентификатор пользователя|
| `body` 	   | Да           |Тело сообщения|
| `deliver_at` | Нет          |Дата отправки. Принимается в формате [ISO8601](https://www.iso.org/iso-8601-date-and-time-format.html). Все даты интерпретируются как даты с часовым поясом UTC. Если значение не передано, в качестве даты отправки используется текущее время|
### Успешный ответ
```json
201 Created

{
  "messages": [
    {
      "id": "f0669405-3ade-4294-9553-af36d255b6b9",
      "status": "pending"
    },
    {
      "id": "b9fe481c-6d2f-4c6b-9895-221ee7229891",
      "status": "pending"
    }
  ]
}
```
| Поле   | Описание |
| ------ |:------------:|
| id     | Идентификатор сообщения|
| status | Текущий статус сообщения. Может иметь следующие значения: `pending`, `sending`, `retrying`, `sent`, `not_sent`|
### Статусы сообщений
| Навание    | Описание                     |
| ---------- |:----------------------------:|
| `pending`  | Принято в обработку|
| `sending`  | В процессе отправки|
| `sent`     | Успешно отправлено|
| `not_sent` | Исчерпано количество повторных отправок|
### Неуспешный ответ
```json
400 Bad request

{
  "errors": "facebook is not a valid type"
}
```
## Получение статуса сообщения
### Запрос
```
GET /messages/:id
```
### Ответ
```json
200 Ok
{
  "id": "b9fe481c-6d2f-4c6b-9895-221ee7229891",
  "type": "telegram",
  "target": "3948758943",
  "body": "message",
  "deliver_at": "2019-02-25T17:58:07",
  "status": "sent"
}
```

# Описание процесса разработки
### Инициализация проекта
Согласно требованиям следует использовать `Ruby on Rails`. Инициализировал фреймворк следующим образом: `rails new microservice_prototype --api -T`. Инициализация с такими опциями создает рельсы в режиме API. Это значит что не будет включен middleware для рендеринга вьюх, сессии итд. `-T` – не использовать фреймворк minitest.

В качестве инструмента тестирования был выбран `rspec`. Дополнительно был установлен гем `database_cleaner`. 

`database_cleaner` [требует указать конфигурацию](https://github.com/DatabaseCleaner/database_cleaner#rspec-example), в которой нужно определить стратегию очистки. Документация rspec предлагает все конфиги класть в файл `rails_helper.rb`. Однако автор считает более правильным держать каждый конфиг в отдельном файле, в папке `spec/support/config`.  А в rails_helper загружать все файлы из этой папки. Для этого раскоментирована соответствующая строка в файле `rails_helper.rb`:

`Dir[Rails.root.join('spec', 'support', '**', '*.rb')].each { |f| require f }`

Также для удобства локального тестирования подключен гем [`guard-rspec`](https://github.com/guard/guard-rspec).

### Отложенная отправка сообщений

Самая сложная задача - отложенная отправка сообщений. Очевидно, что взаимодействие со сторонними сервисами должно быть реализовано через бекграунд джобы. Существуют следующие инструменты:

* [**delayed_job**](https://github.com/collectiveidea/delayed_job)
* [**sidekiq**](https://github.com/mperham/sidekiq/)
* [**rescue**](https://github.com/resque/resque)
* [**sucker_punch**](https://github.com/brandonhilkert/sucker_punch)
* [**Que**](https://github.com/chanks/que)
* [**Async adapter**](https://api.rubyonrails.org/classes/ActiveJob/QueueAdapters/AsyncAdapter.html)

Почти все перечисленные библиотеки используют, в качестве хранилища, базы данных. В требованиях к задаче указано что приложение можно будет запустить независимо от окружения. Соотвественно, гемы использующие БД в качестве зависимости не подойдут. Среди таких `delayed_job`, `sidekiq`, `rescue`. 

`sidekiq` использует redis, который по-умолчанию хранит все в ОЗУ, т.е. данные могут легко потеряться. Из плюсов можно отметить идущую из коробки панель управления.

`sucker_punch` не использует БД, хранит все в памяти. Это значит не надо тянуть никаких зависимостей. В отличии от `DJ`, `sidekiq` и `resque`, ему не нужен дополнительный процесс. Может быть плюсом если приложение деплоится, например, на хероку, так как не надо будет платить за дополнительный воркер. Само собой, это все является и минусом, если система упадет все джобы потеряются. Например, тот же хероку перезагружает дино раз в день. Авторы гема рекомендуют использовать его только для быстрых некритичных тасков.

`Async adapter` – дефолтный адаптер для ActiveJob начиная с пятых рельс ([см. коммит DHH](https://github.com/rails/rails/commit/625baa69d14881ac49ba2e5c7d9cac4b222d7022)). Используется только для dev/test окружения, также как и `sucker_punch` использует `concurrent-ruby` и хранит все в памяти.

Для задачи создания прототипа микросервиса идеально подходит `Async adapter`, так как это тестовое задание и сделать его надо как можно быстрее. К тому же, неизвестно будет ли доступна БД в окружении, в котором будет запускаться приложение.

Разумеется, в настоящем приложении следует использовать `DJ`, `resque` или `sidekiq`.

### Структура хранения
Теперь надо подумать над структурой сообщений приходящих по API. Мне очень нравится спецификация [JSON API](https://jsonapi.org/), но так как приложение задумывается как часть микросервисной структуры, а не веб-апи, то пока ограничимся максимально простой структурой. Максимально простой структурой будет следующая - массив, каждый элемент которого это объект, содержащий данные одного сообщения. Для простоты предположим, что в поле `target` передается конечный идентификатор пользователя, принимающийся сторонним сервисом. `deliver_at` - необязательное поле, в случае его отсутствия сообщение отправляется в самое ближайшее время.

```json
POST /messages

[
  {
    "type": "whatsapp",
    "target": "3948758943",
    "body": "message",
    "deliver_at": ""
  },
  {
    "type": "telegram",
    "target": "3948758943",
    "body": "message"
  }
]
```
Однако после обдумывания, выявил ошибку в этой структуре, где корнем является массив. В будущем сложно будет добавлять дополнительные ключи в сообщение. Более подходящей будет следующая структура сообщений:

```json
POST /message
{
  "messages": [
    {
      "type": "whatsapp",
      "target": "3948758943",
      "body": "message",
      "deliver_at": ""
    },
    {
      "type": "telegram",
      "target": "3948758943",
      "body": "message"
    }
  ]
}
```

Основная модель, хранящая сами сообщения, называется `Message`.  В настоящем приложении потребовалась бы еще одна таблица, хранящая все попытки отправки, которая называлась бы, например, `delivers`. Для прототипа же это не так важно.
Таблица `messages` имеет столбцы `type`, `target`, `body`, `deliver_at`, `status`, `delivered_at`, `retries_count`. Так как `type` зарезервированное название столбца, которое `ActiveRecord` использует для реализации `STI`, в файле модели присутствует строка `self.inheritance_column = :_type_disabled`.
Поле `retries_count` хранит количество совершенных попыток отправки. Хорошей практикой является подход, когда между попытками отправки время должно возрастать в геометрической прогрессии. Опять же, в прототипе не имеет смысла это реализовывать.

Поля `type` и `status` представлены в модели как `enum`.

```ruby
  enum type: {
    viber:    "viber",
    telegram: "telegram",
    whatsapp: "whatsapp"
  }

  enum status: {
    pending:  "pending",
    sending:  "sending",
    retrying: "retrying",
    sent:     "sent",
    not_sent: "not_sent"
  }
```
Объявление `enum` как хэша, в котором значения являются строками, позволяет хранить в таблице читаемые строки, а не магические числа. К тому же если бы `enum` был объявлен как массив, то в случае добавления новых позиций, их можно было бы добавлять только в конец массива.

Все условия и ограничения реализованы только на уровне приложения. В настоящем же микросервисе следует продублировать их также и на уровне БД. Помимо сохранения целостности данных, дублирование ограничений на уровне БД позволяет, например, в случае `enum` проставить индексы на это поле. Но тут также есть свои [проблемы](https://sipsandbits.com/2018/04/30/using-database-native-enums-with-rails/).

### Валидации
Для ускорения процесса разработки все валидации объявлены в самой модели, однако следует разделять логику работы с хранилищем и валидацию данных. Т.е., рекомендуется держать валидации отдельно. Например, вынести все в отдельный класс-валидатор.

Для поля `state` в условиях реального проекта, в целях сохранения целостности данных, следует использовать стейт–машину. Например, гем [acts_as_state_machine](https://github.com/aasm/aasm).

### Тестирование
Использование рельсов только в режиме АПИ, позволяет не писать тесты на модели, контроллеры и роуты, а ограничиться лишь request-тестами, которые протестируют сразу все вышеперечисленное. К тому же команда рельсов и `rspec` [рекомендует](http://rspec.info/blog/2016/07/rspec-3-5-has-been-released/) писать request-тесты вместо контроллер-тестов.

В файле messages_spec.rb определенны два вспомогательных метода: `json_response` `error_message`. Объявлены эти методы прямо в самом spec-файле так как больше нигде кроме этого файла они не используются. В случае, если хелперы понадобятся в других файлах, следует их вынести в отдельный модуль, который подключить в `rails_helper.rb`.

```ruby
RSpec.configuration do |config|
  config.include RequestSpecHelper, type: :request
end
```

Для тестов, зависящих от времени, используется библиотека [timecop](https://github.com/travisjeffery/timecop).

```ruby
let(:current_time) { Time.zone.now }

before { Timecop.freeze(current_time) }
after  { Timecop.return }

it 'sets current time as delivery time' do
  expect(message.deliver_at).to eql(current_time)
end
```
Стоит обратить внимание на использование конструкции `Time.zone.now`, а не `Time.now`. `Time.now`, являясь частью ядра руби, не учитывает часовой пояс указанный в rails-приложении, используя системную таймзону.

Логику сохранения и обработки сообщений вынесена в интерактор-органайзер. Интерактор - [паттерн](https://ebi.readthedocs.io/en/latest/), являющийся частью [DDD](https://en.wikipedia.org/wiki/Domain-driven_design). DDD трудно реализуем в рельсах, однако в случае интеракторов существует, используемый мною [одноименный гем](https://github.com/collectiveidea/interactor). Паттерн интерактор напоминает паттерн сервис-обжект, однако имеет свои отличия. Преимущество, упомянутого, гема в возможности организовывать код в т.н. органайзеры.

```ruby
class ProcessMessage
  include Interactor::Organizer

  organize SaveMessage, DeliverMessage
end
```

В [статье Ивана Шаматова](https://mkdev.me/en/posts/a-couple-of-words-about-interactors-in-rails) рассказано об этом геме подробнее.

В контроллерах не используется никакой сериалайзер, так как только в одном месте происходит сериализация объекта `message` в `json`.

---

Можно заметить, что все сообщения коммитов имеют один стиль.

```
* Create README (2 minutes ago)
* Implement logic for delivering messages (4 hours ago)
* Implement showing messages by id (7 hours ago)
* Implement receiving and saving message through API (27 hours ago)
* Add guard gem (30 hours ago)
* Create Message model (31 hours ago)
* Initialise rails app (34 hours ago)
```
Автор придерживается описанного [здесь](https://chris.beams.io/posts/git-commit/) соглашения наименования коммитов.

---

В прототипе не реализован механизм авторизации/аутентификации, а также нет версионирования АПИ. Связано это с отсутствием соответствующего требования. Однако, в случае боевого приложения, это конечно же следует реализовать.

## TODO
* В качестве идентификатора сообщений использовать UUID
* Инкрементить счетчик `retries_count`, в случае неуспешной отправки сообщения